import React, { useState } from 'react';
import { 
  WrenchScrewdriverIcon,
  ShieldCheckIcon,
  ExclamationTriangleIcon,
  SparklesIcon
} from '@heroicons/react/24/outline';
import { FixSuggestionModal } from '../VulnerabilityTable/FixSuggestionModal';
import type { Vulnerability, FixSuggestion } from '../../types';

interface FixButtonProps {
  vulnerability: Vulnerability;
  suggestion: FixSuggestion;
  size?: 'xs' | 'sm' | 'md' | 'lg';
  variant?: 'primary' | 'secondary' | 'minimal';
  showIcon?: boolean;
}

const sizeConfig = {
  xs: {
    padding: 'px-2 py-1',
    text: 'text-xs',
    iconSize: 'h-3 w-3',
  },
  sm: {
    padding: 'px-3 py-1.5',
    text: 'text-xs',
    iconSize: 'h-4 w-4',
  },
  md: {
    padding: 'px-4 py-2',
    text: 'text-sm',
    iconSize: 'h-4 w-4',
  },
  lg: {
    padding: 'px-6 py-3',
    text: 'text-base',
    iconSize: 'h-5 w-5',
  },
};

const getUpdateTypeIcon = (updateType: string) => {
  switch (updateType) {
    case 'patch':
      return ShieldCheckIcon;
    case 'minor':
      return WrenchScrewdriverIcon;
    case 'major':
      return ExclamationTriangleIcon;
    case 'alternative':
      return SparklesIcon;
    default:
      return WrenchScrewdriverIcon;
  }
};

const getUpdateTypeColor = (updateType: string) => {
  switch (updateType) {
    case 'patch':
      return 'text-green-700 bg-green-100 border-green-200 hover:bg-green-200';
    case 'minor':
      return 'text-blue-700 bg-blue-100 border-blue-200 hover:bg-blue-200';
    case 'major':
      return 'text-orange-700 bg-orange-100 border-orange-200 hover:bg-orange-200';
    case 'alternative':
      return 'text-purple-700 bg-purple-100 border-purple-200 hover:bg-purple-200';
    default:
      return 'text-gray-700 bg-gray-100 border-gray-200 hover:bg-gray-200';
  }
};

export const FixButton: React.FC<FixButtonProps> = ({
  vulnerability,
  suggestion,
  size = 'sm',
  variant = 'secondary',
  showIcon = true,
}) => {
  const [showModal, setShowModal] = useState(false);
  const sizeClass = sizeConfig[size];
  const IconComponent = getUpdateTypeIcon(suggestion.updateType);
  
  const primaryDep = vulnerability.affectedDependencies?.[0];
  
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    
    // Helper function to extract recommended version from JIRA recommendedActions
    const extractRecommendedVersion = (): string => {
      // First check if targetVersion is already set in dependency data
      if (primaryDep?.targetVersion && primaryDep.targetVersion !== 'latest') {
        return primaryDep.targetVersion;
      }
      
      // Extract from JIRA ticket recommendedActions (primary source)
      if ((vulnerability as any).jiraTicket?.wizFindings?.length > 0) {
        for (const finding of (vulnerability as any).jiraTicket.wizFindings) {
          if (finding.recommendedActions) {
            for (const action of finding.recommendedActions) {
              // Parse "Update commons-io:commons-io to version 2.15.1"
              const versionMatch = action.match(/(?:update|upgrade).*?(?:to\s+)?version\s+([0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9.-]*)/i);
              if (versionMatch) {
                return versionMatch[1];
              }
            }
          }
        }
      }
      
      // Fallback: extract from vulnerability description
      if (vulnerability.description) {
        const versionMatch = vulnerability.description.match(/Recommended Version:\s*([^\n\r*]+)/i);
        if (versionMatch) {
          return versionMatch[1].replace(/\*/g, '').trim();
        }
      }
      
      // Use suggestion's version if available
      if (suggestion?.suggestedVersion && suggestion.suggestedVersion !== 'latest') {
        return suggestion.suggestedVersion;
      }
      
      // Last fallback
      return 'latest';
    };
    
    const recommendedVersion = extractRecommendedVersion();
    
    // Create enhanced fix suggestion with actual resolved versions
    const enhancedFix = {
      ...suggestion,
      dependencyName: primaryDep?.name || suggestion.dependencyName,
      currentVersion: primaryDep?.version || suggestion.currentVersion,
      suggestedVersion: recommendedVersion,
      recommendedVersion: recommendedVersion,
      affectedVersion: primaryDep?.version || suggestion.currentVersion,
      latestVersion: 'latest',
      // Filter breaking changes to only include compatible types
      breakingChanges: suggestion.breakingChanges?.filter(bc => 
        ['api', 'behavior', 'dependency'].includes(bc.type)
      ).map(bc => ({
        type: bc.type as 'api' | 'behavior' | 'dependency',
        description: bc.description,
        mitigation: bc.mitigation,
      })) || [],
    };
    
    setShowModal(true);
  };

  const getVariantClasses = () => {
    switch (variant) {
      case 'primary':
        return `
          text-white bg-blue-600 border-blue-600 
          hover:bg-blue-700 hover:border-blue-700
          focus:ring-blue-500
        `;
      case 'secondary':
        return `
          border ${getUpdateTypeColor(suggestion.updateType)}
        `;
      case 'minimal':
        return `
          text-blue-600 hover:text-blue-700 hover:bg-blue-50
          border-transparent
        `;
      default:
        return getUpdateTypeColor(suggestion.updateType);
    }
  };

  return (
    <>
      <button
        onClick={handleClick}
        className={`
          inline-flex items-center font-medium rounded-md transition-colors duration-150
          focus:outline-none focus:ring-2 focus:ring-offset-2
          ${sizeClass.padding} ${sizeClass.text}
          ${getVariantClasses()}
        `}
        title={`${suggestion.updateType.charAt(0).toUpperCase() + suggestion.updateType.slice(1)} update available`}
      >
        {showIcon && (
          <IconComponent className={`${sizeClass.iconSize} ${size === 'xs' ? '' : 'mr-2'}`} />
        )}
        {size !== 'xs' && (
          <span>
            {variant === 'minimal' ? 'Fix' : `${suggestion.updateType.charAt(0).toUpperCase() + suggestion.updateType.slice(1)} Fix`}
          </span>
        )}
      </button>

      {showModal && (
        <FixSuggestionModal
          fixSuggestion={(() => {
            // Helper function to extract recommended version from JIRA recommendedActions
            const extractRecommendedVersion = (): string => {
              // First check if targetVersion is already set in dependency data
              if (primaryDep?.targetVersion && primaryDep.targetVersion !== 'latest') {
                return primaryDep.targetVersion;
              }
              
              // Extract from JIRA ticket recommendedActions (primary source)
              if ((vulnerability as any).jiraTicket?.wizFindings?.length > 0) {
                for (const finding of (vulnerability as any).jiraTicket.wizFindings) {
                  if (finding.recommendedActions) {
                    for (const action of finding.recommendedActions) {
                      // Parse "Update commons-io:commons-io to version 2.15.1"
                      const versionMatch = action.match(/(?:update|upgrade).*?(?:to\s+)?version\s+([0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9.-]*)/i);
                      if (versionMatch) {
                        return versionMatch[1];
                      }
                    }
                  }
                }
              }
              
              // Fallback: extract from vulnerability description
              if (vulnerability.description) {
                const versionMatch = vulnerability.description.match(/Recommended Version:\s*([^\n\r*]+)/i);
                if (versionMatch) {
                  return versionMatch[1].replace(/\*/g, '').trim();
                }
              }
              
              // Use suggestion's version if available
              if (suggestion?.suggestedVersion && suggestion.suggestedVersion !== 'latest') {
                return suggestion.suggestedVersion;
              }
              
              // Last fallback
              return 'latest';
            };
            
            const recommendedVersion = extractRecommendedVersion();
            
            return {
              ...suggestion,
              dependencyName: primaryDep?.name || suggestion.dependencyName,
              currentVersion: primaryDep?.version || suggestion.currentVersion,
              suggestedVersion: recommendedVersion,
              recommendedVersion: recommendedVersion,
              affectedVersion: primaryDep?.version || suggestion.currentVersion,
              latestVersion: 'latest',
              // Filter breaking changes to only include compatible types
              breakingChanges: suggestion.breakingChanges?.filter(bc => 
                ['api', 'behavior', 'dependency'].includes(bc.type)
              ).map(bc => ({
                type: bc.type as 'api' | 'behavior' | 'dependency',
                description: bc.description,
                mitigation: bc.mitigation,
              })) || [],
            };
          })()}
          onClose={() => setShowModal(false)}
        />
      )}
    </>
  );
}; 