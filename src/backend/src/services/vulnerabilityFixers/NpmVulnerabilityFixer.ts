import { FileParserService } from '../fileParser/FileParserService';
import { logger } from '../../utils/logger';

export interface VulnerabilityFix {
  dependencyName: string;
  currentVersion: string;
  recommendedVersion: string;
  cveId: string;
  severity: string;
  description: string;
}

export interface FixResult {
  filesModified: number;
  errors: string[];
  modifiedFiles: string[];
  npmFilesModified: number;
}

export class NpmVulnerabilityFixer {
  private fileParserService: FileParserService;

  constructor() {
    this.fileParserService = new FileParserService();
  }

  /**
   * Apply vulnerability fixes specifically to NPM package.json files
   * Reuses existing FileParserService logic but provides NPM-specific interface
   */
  async applyNpmVulnerabilityFixes(
    parsingResults: any[],
    vulnerabilityFixes: VulnerabilityFix[],
    dependencies: any[]
  ): Promise<FixResult> {
    logger.info('🔧 NPM VULNERABILITY FIXER - Starting NPM-specific fixes');
    
    const result: FixResult = {
      filesModified: 0,
      errors: [],
      modifiedFiles: [],
      npmFilesModified: 0
    };

    try {
      // Filter parsing results to only NPM files
      const npmParsingResults = parsingResults.filter(result => 
        result.filePath?.endsWith('package.json') || 
        result.fileType === 'npm'
      );

      if (npmParsingResults.length === 0) {
        logger.warn('⚠️ No NPM package.json files found for vulnerability fixes');
        return result;
      }

      logger.info(`📦 Found ${npmParsingResults.length} NPM files to process`);
      logger.info(`🔧 Applying ${vulnerabilityFixes.length} vulnerability fixes to NPM files`);

      // Reuse existing FileParserService.applyVulnerabilityFixes method
      // This method already handles NPM files correctly
      const updatedParsingResults = await this.fileParserService.applyVulnerabilityFixes(
        npmParsingResults,
        vulnerabilityFixes,
        dependencies
      );

      // Write modified NPM files to disk using existing tested method
      const writeResults = await this.fileParserService.writeModifiedFiles(updatedParsingResults);
      
      result.filesModified = writeResults.written;
      result.errors = writeResults.errors;
      result.npmFilesModified = writeResults.written;

      // Track modified NPM files for audit trail
      const modifiedFiles = updatedParsingResults.filter(result => result.applied);
      result.modifiedFiles = modifiedFiles.map(f => f.filePath);

      logger.info(`✅ Successfully modified ${result.npmFilesModified} NPM files`);
      
      if (result.errors.length > 0) {
        logger.warn(`⚠️ Some NPM files failed to write:`, result.errors);
      }

      // Log modified files for audit trail
      if (result.modifiedFiles.length > 0) {
        logger.info('📝 Modified NPM files:', result.modifiedFiles);
      }

    } catch (error) {
      const errorMessage = `Failed to apply NPM vulnerability fixes: ${error}`;
      logger.error('❌ NPM vulnerability fixer error:', error);
      result.errors.push(errorMessage);
    }

    return result;
  }

  /**
   * Filter suggestions to only NPM-related ones
   */
  filterNpmSuggestions(suggestions: any[]): any[] {
    return suggestions.filter(suggestion => 
      suggestion.packageManager === 'npm' || 
      suggestion.filePath?.endsWith('package.json')
    );
  }

  /**
   * Convert suggestions to VulnerabilityFix format for NPM
   */
  convertToNpmVulnerabilityFixes(suggestions: any[]): VulnerabilityFix[] {
    return suggestions.map(suggestion => ({
      dependencyName: suggestion.dependencyName,
      currentVersion: suggestion.currentVersion,
      recommendedVersion: suggestion.suggestedVersion,
      cveId: suggestion.fixesVulnerabilities?.[0] || 'Unknown',
      severity: 'medium',
      description: `Security update for ${suggestion.dependencyName}`
    }));
  }

  /**
   * Validate NPM files after modification
   */
  async validateNpmFiles(parsingResults: any[]): Promise<{ valid: boolean; errors: string[] }> {
    const npmResults = parsingResults.filter(result => 
      result.filePath?.endsWith('package.json') || 
      result.fileType === 'npm'
    );

    if (npmResults.length === 0) {
      return { valid: true, errors: [] };
    }

    // Reuse existing validation logic from FileParserService
    return await this.fileParserService.validateModifiedFiles(npmResults);
  }

  /**
   * Generate NPM-specific build commands
   */
  generateNpmBuildCommands(parsingResults: any[]): string[] {
    const npmResults = parsingResults.filter(result => 
      result.filePath?.endsWith('package.json') || 
      result.fileType === 'npm'
    );

    if (npmResults.length === 0) {
      return [];
    }

    // Reuse existing build command generation from FileParserService
    const allCommands = this.fileParserService.generateBuildCommands(npmResults);
    
    // Filter to only NPM-specific commands
    return allCommands.filter(cmd => 
      cmd.includes('npm') || 
      cmd.includes('yarn') ||
      cmd.includes('package.json')
    );
  }
} 