import { FileParserService } from '../fileParser/FileParserService';
import { logger } from '../../utils/logger';

export interface VulnerabilityFix {
  dependencyName: string;
  currentVersion: string;
  recommendedVersion: string;
  cveId: string;
  severity: string;
  description: string;
}

export interface FixResult {
  filesModified: number;
  errors: string[];
  modifiedFiles: string[];
  gradleFilesModified: number;
}

export class GradleVulnerabilityFixer {
  private fileParserService: FileParserService;

  constructor() {
    this.fileParserService = new FileParserService();
  }

  /**
   * Apply vulnerability fixes specifically to Gradle files
   * Reuses existing FileParserService logic but provides Gradle-specific interface
   */
  async applyGradleVulnerabilityFixes(
    parsingResults: any[],
    vulnerabilityFixes: VulnerabilityFix[],
    dependencies: any[]
  ): Promise<FixResult> {
    logger.info('ðŸ”§ GRADLE VULNERABILITY FIXER - Starting Gradle-specific fixes');
    
    const result: FixResult = {
      filesModified: 0,
      errors: [],
      modifiedFiles: [],
      gradleFilesModified: 0
    };

    try {
      // Filter parsing results to only Gradle files
      const gradleParsingResults = parsingResults.filter(result => 
        result.filePath?.endsWith('.gradle') || 
        result.fileType === 'gradle'
      );

      if (gradleParsingResults.length === 0) {
        logger.warn('âš ï¸ No Gradle files found for vulnerability fixes');
        return result;
      }

      logger.info(`ðŸ“¦ Found ${gradleParsingResults.length} Gradle files to process`);
      logger.info(`ðŸ”§ Applying ${vulnerabilityFixes.length} vulnerability fixes to Gradle files`);

      // Reuse existing FileParserService.applyVulnerabilityFixes method
      // This method already handles Gradle files correctly
      const updatedParsingResults = await this.fileParserService.applyVulnerabilityFixes(
        gradleParsingResults,
        vulnerabilityFixes,
        dependencies
      );

                        // Debug: Check which files were actually modified
                  const appliedFiles = updatedParsingResults.filter(result => result.applied);
                  logger.info(`ðŸ” Gradle files marked as applied: ${appliedFiles.length}/${updatedParsingResults.length}`);
                  appliedFiles.forEach(file => {
                    logger.info(`âœ… Applied fixes to: ${file.filePath}`);
                  });

                  // Debug: Check file content before writing
                  appliedFiles.forEach(file => {
                    logger.info(`ðŸ” File content preview for ${file.filePath}:`);
                    if (file.modification && 'content' in file.modification) {
                      const content = (file.modification as any).content;
                      const preview = content.substring(0, 500) + '...';
                      logger.info(`ðŸ“„ Content preview: ${preview}`);
                    }
                  });

      // Write modified Gradle files to disk using existing tested method
      const writeResults = await this.fileParserService.writeModifiedFiles(updatedParsingResults);
      
      result.filesModified = writeResults.written;
      result.errors = writeResults.errors;
      result.gradleFilesModified = writeResults.written;

      // Track modified Gradle files for audit trail
      const modifiedFiles = updatedParsingResults.filter(result => result.applied);
      result.modifiedFiles = modifiedFiles.map(f => f.filePath);

      logger.info(`âœ… Successfully modified ${result.gradleFilesModified} Gradle files`);
      
      if (result.errors.length > 0) {
        logger.warn(`âš ï¸ Some Gradle files failed to write:`, result.errors);
      }

      // Log modified files for audit trail
      if (result.modifiedFiles.length > 0) {
        logger.info('ðŸ“ Modified Gradle files:', result.modifiedFiles);
      }

    } catch (error) {
      const errorMessage = `Failed to apply Gradle vulnerability fixes: ${error}`;
      logger.error('âŒ Gradle vulnerability fixer error:', error);
      result.errors.push(errorMessage);
    }

    return result;
  }

  /**
   * Filter suggestions to only Gradle-related ones
   */
  filterGradleSuggestions(suggestions: any[]): any[] {
    return suggestions.filter(suggestion => 
      suggestion.packageManager === 'gradle' || 
      suggestion.filePath?.endsWith('.gradle')
    );
  }

  /**
   * Convert suggestions to VulnerabilityFix format for Gradle
   */
  convertToGradleVulnerabilityFixes(suggestions: any[]): VulnerabilityFix[] {
    return suggestions.map(suggestion => ({
      dependencyName: suggestion.dependencyName,
      currentVersion: suggestion.currentVersion,
      recommendedVersion: suggestion.suggestedVersion,
      cveId: suggestion.fixesVulnerabilities?.[0] || 'Unknown',
      severity: 'medium',
      description: `Security update for ${suggestion.dependencyName}`
    }));
  }

  /**
   * Validate Gradle files after modification
   */
  async validateGradleFiles(parsingResults: any[]): Promise<{ valid: boolean; errors: string[] }> {
    const gradleResults = parsingResults.filter(result => 
      result.filePath?.endsWith('.gradle') || 
      result.fileType === 'gradle'
    );

    if (gradleResults.length === 0) {
      return { valid: true, errors: [] };
    }

    // Reuse existing validation logic from FileParserService
    return await this.fileParserService.validateModifiedFiles(gradleResults);
  }

  /**
   * Generate Gradle-specific build commands
   */
  generateGradleBuildCommands(parsingResults: any[]): string[] {
    const gradleResults = parsingResults.filter(result => 
      result.filePath?.endsWith('.gradle') || 
      result.fileType === 'gradle'
    );

    if (gradleResults.length === 0) {
      return [];
    }

    // Reuse existing build command generation from FileParserService
    const allCommands = this.fileParserService.generateBuildCommands(gradleResults);
    
    // Filter to only Gradle-specific commands
    return allCommands.filter(cmd => 
      cmd.includes('gradle') || 
      cmd.includes('gradlew') ||
      cmd.includes('./gradlew')
    );
  }
} 