import { FileParserService } from '../fileParser/FileParserService';
import { logger } from '../../utils/logger';

export interface VulnerabilityFix {
  dependencyName: string;
  currentVersion: string;
  recommendedVersion: string;
  cveId: string;
  severity: string;
  description: string;
}

export interface FixResult {
  filesModified: number;
  errors: string[];
  modifiedFiles: string[];
  mavenFilesModified: number;
}

export class MavenVulnerabilityFixer {
  private fileParserService: FileParserService;

  constructor() {
    this.fileParserService = new FileParserService();
  }

  /**
   * Apply vulnerability fixes specifically to Maven files
   * Reuses existing FileParserService logic but provides Maven-specific interface
   */
  async applyMavenVulnerabilityFixes(
    parsingResults: any[],
    vulnerabilityFixes: VulnerabilityFix[],
    dependencies: any[]
  ): Promise<FixResult> {
    logger.info('🔧 MAVEN VULNERABILITY FIXER - Starting Maven-specific fixes');
    
    const result: FixResult = {
      filesModified: 0,
      errors: [],
      modifiedFiles: [],
      mavenFilesModified: 0
    };

    try {
      // Filter parsing results to only Maven files
      const mavenParsingResults = parsingResults.filter(result => 
        result.filePath?.endsWith('pom.xml') || 
        result.fileType === 'maven'
      );

      if (mavenParsingResults.length === 0) {
        logger.warn('⚠️ No Maven files found for vulnerability fixes');
        return result;
      }

      logger.info(`📦 Found ${mavenParsingResults.length} Maven files to process`);
      logger.info(`🔧 Applying ${vulnerabilityFixes.length} vulnerability fixes to Maven files`);

      // Reuse existing FileParserService.applyVulnerabilityFixes method
      // This method already handles Maven files correctly
      const updatedParsingResults = await this.fileParserService.applyVulnerabilityFixes(
        mavenParsingResults,
        vulnerabilityFixes,
        dependencies
      );

                        // Debug: Check which files were actually modified
                  const appliedFiles = updatedParsingResults.filter(result => result.applied);
                  logger.info(`🔍 Maven files marked as applied: ${appliedFiles.length}/${updatedParsingResults.length}`);
                  appliedFiles.forEach(file => {
                    logger.info(`✅ Applied fixes to: ${file.filePath}`);
                  });

                  // Debug: Check file content before writing
                  appliedFiles.forEach(file => {
                    logger.info(`🔍 File content preview for ${file.filePath}:`);
                    if (file.modification && 'content' in file.modification) {
                      const content = (file.modification as any).content;
                      const preview = content.substring(0, 500) + '...';
                      logger.info(`📄 Content preview: ${preview}`);
                    }
                  });

      // Write modified Maven files to disk using existing tested method
      const writeResults = await this.fileParserService.writeModifiedFiles(updatedParsingResults);
      
      result.filesModified = writeResults.written;
      result.errors = writeResults.errors;
      result.mavenFilesModified = writeResults.written;

      // Track modified Maven files for audit trail
      const modifiedFiles = updatedParsingResults.filter(result => result.applied);
      result.modifiedFiles = modifiedFiles.map(f => f.filePath);

      logger.info(`✅ Successfully modified ${result.mavenFilesModified} Maven files`);
      
      if (result.errors.length > 0) {
        logger.warn(`⚠️ Some Maven files failed to write:`, result.errors);
      }

      // Log modified files for audit trail
      if (result.modifiedFiles.length > 0) {
        logger.info('📝 Modified Maven files:', result.modifiedFiles);
      }

    } catch (error) {
      const errorMessage = `Failed to apply Maven vulnerability fixes: ${error}`;
      logger.error('❌ Maven vulnerability fixer error:', error);
      result.errors.push(errorMessage);
    }

    return result;
  }

  /**
   * Filter suggestions to only Maven-related ones
   */
  filterMavenSuggestions(suggestions: any[]): any[] {
    return suggestions.filter(suggestion => 
      suggestion.packageManager === 'maven' || 
      suggestion.filePath?.endsWith('pom.xml')
    );
  }

  /**
   * Convert suggestions to VulnerabilityFix format for Maven
   */
  convertToMavenVulnerabilityFixes(suggestions: any[]): VulnerabilityFix[] {
    return suggestions.map(suggestion => ({
      dependencyName: suggestion.dependencyName,
      currentVersion: suggestion.currentVersion,
      recommendedVersion: suggestion.suggestedVersion,
      cveId: suggestion.fixesVulnerabilities?.[0] || 'Unknown',
      severity: 'medium',
      description: `Security update for ${suggestion.dependencyName}`
    }));
  }

  /**
   * Validate Maven files after modification
   */
  async validateMavenFiles(parsingResults: any[]): Promise<{ valid: boolean; errors: string[] }> {
    const mavenResults = parsingResults.filter(result => 
      result.filePath?.endsWith('pom.xml') || 
      result.fileType === 'maven'
    );

    if (mavenResults.length === 0) {
      return { valid: true, errors: [] };
    }

    // Reuse existing validation logic from FileParserService
    return await this.fileParserService.validateModifiedFiles(mavenResults);
  }

  /**
   * Generate Maven-specific build commands
   */
  generateMavenBuildCommands(parsingResults: any[]): string[] {
    const mavenResults = parsingResults.filter(result => 
      result.filePath?.endsWith('pom.xml') || 
      result.fileType === 'maven'
    );

    if (mavenResults.length === 0) {
      return [];
    }

    // Reuse existing build command generation from FileParserService
    const allCommands = this.fileParserService.generateBuildCommands(mavenResults);
    
    // Filter to only Maven-specific commands
    return allCommands.filter(cmd => 
      cmd.includes('mvn') || 
      cmd.includes('maven') ||
      cmd.includes('pom.xml')
    );
  }
} 