import { logger } from '../../utils/logger';
import { 
  Vulnerability, 
  Dependency, 
  JiraTicket, 
  VulnerabilityMatch,
  FixSuggestion 
} from '../../types';
import semver from 'semver';

export class VulnerabilityMatcher {
  /**
   * Match vulnerabilities with affected dependencies and JIRA tickets
   */
  async matchVulnerabilities(
    vulnerabilities: Vulnerability[],
    affectedDependencies: Dependency[],
    jiraTickets: JiraTicket[]
  ): Promise<VulnerabilityMatch[]> {
    try {
      logger.info(`🔍 VULNERABILITY MATCHER DEBUG:`);
      logger.info(`  • ${vulnerabilities.length} vulnerabilities to process`);
      logger.info(`  • ${affectedDependencies.length} dependencies in repository`);
      logger.info(`  • ${jiraTickets.length} JIRA tickets`);

      // Log sample dependencies for debugging
      logger.info(`📦 Sample dependencies found:`, {
        gradle: affectedDependencies.filter(d => d.packageManager === 'gradle').slice(0, 5).map(d => `${d.name}:${d.version}`),
        maven: affectedDependencies.filter(d => d.packageManager === 'maven').slice(0, 5).map(d => `${d.name}:${d.version}`),
        npm: affectedDependencies.filter(d => d.packageManager === 'npm').slice(0, 5).map(d => `${d.name}:${d.version}`),
        byManager: affectedDependencies.reduce((acc, d) => {
          acc[d.packageManager] = (acc[d.packageManager] || 0) + 1;
          return acc;
        }, {} as Record<string, number>)
      });

      // Log sample vulnerabilities
      logger.info(`🚨 Vulnerabilities to match:`, {
        vulnerabilities: vulnerabilities.map(v => ({
          id: v.id,
          cveId: v.cveId,
          title: v.title,
          affectedPackagesCount: v.affectedPackages.length,
          affectedPackages: v.affectedPackages.map(p => `${p.name} (${p.ecosystem})`)
        }))
      });

      const matches: VulnerabilityMatch[] = [];

      for (const vulnerability of vulnerabilities) {
        logger.info(`\n🔎 Processing vulnerability: ${vulnerability.id} (${vulnerability.cveId})`);
        
        // Enhanced dependency matching with multiple strategies
        const matchingDependencies = this.findMatchingDependencies(vulnerability, affectedDependencies);

        if (matchingDependencies.length > 0) {
          logger.info(`✅ MATCH SUCCESS: Found ${matchingDependencies.length} matching dependencies for ${vulnerability.id}`);
        } else {
          logger.warn(`❌ MATCH FAILED: No matching dependencies found for ${vulnerability.id}`);
          logger.warn(`   Affected packages: ${vulnerability.affectedPackages.map(p => `${p.name} (${p.ecosystem})`).join(', ')}`);
        }

        // Find associated JIRA ticket
        const associatedTicket = jiraTickets.find(ticket => 
          ticket.wizFindings?.some(finding => 
            finding.cveIds.includes(vulnerability.cveId || '') ||
            finding.id === vulnerability.id
          )
        );

        // Generate fix suggestions for this vulnerability
        const fixSuggestions = await this.generateFixSuggestions(
          vulnerability,
          matchingDependencies
        );

        if (matchingDependencies.length > 0) {
          const match: VulnerabilityMatch = {
            vulnerability,
            affectedDependencies: matchingDependencies,
            jiraTicket: associatedTicket,
            fixSuggestions,
          };

          matches.push(match);
          logger.info(`✅ Matched vulnerability ${vulnerability.id} with ${matchingDependencies.length} dependencies`);
        }
      }

      logger.info(`\n📊 FINAL RESULTS:`);
      logger.info(`  • ${matches.length} successful matches out of ${vulnerabilities.length} vulnerabilities`);
      logger.info(`  • ${vulnerabilities.length - matches.length} vulnerabilities will be classified as false positives`);
      
      // Log which vulnerabilities became false positives
      const matchedVulnIds = new Set(matches.map(m => m.vulnerability.id));
      const falsePositives = vulnerabilities.filter(v => !matchedVulnIds.has(v.id));
      
      if (falsePositives.length > 0) {
        logger.warn(`🚨 FALSE POSITIVES (${falsePositives.length} vulnerabilities):`);
        falsePositives.forEach((fp, index) => {
          logger.warn(`❌ False Positive ${index + 1}: ${fp.cveId || fp.id} - ${fp.title}`, {
            id: fp.id,
            cveId: fp.cveId,
            affectedPackages: fp.affectedPackages.map((p: any) => `${p.name} (${p.ecosystem})`)
          });
        });
      }
      
      return matches;
    } catch (error: any) {
      logger.error('Error matching vulnerabilities:', error);
      throw new Error(`Failed to match vulnerabilities: ${error.message}`);
    }
  }

  /**
   * Enhanced dependency matching with multiple strategies
   */
  private findMatchingDependencies(vulnerability: Vulnerability, dependencies: Dependency[]): Dependency[] {
    const matches: Dependency[] = [];

    logger.info(`    📋 Finding matches for ${vulnerability.affectedPackages.length} affected packages:`);

    for (const affectedPackage of vulnerability.affectedPackages) {
      // Smart filtering: Skip obvious garbage data but preserve legitimate packages
      if (!this.isLegitimatePackage(affectedPackage.name)) {
        logger.debug(`    🗑️ Skipping garbage package: ${affectedPackage.name}`);
        continue;
      }
      
      logger.info(`    🔍 Looking for package: "${affectedPackage.name}" (${affectedPackage.ecosystem})`);
      logger.info(`    📊 Available dependency ecosystems:`, {
        ecosystems: [...new Set(dependencies.map(d => d.packageManager))],
        normalizedEcosystem: this.normalizeEcosystem(affectedPackage.ecosystem),
        matchingEcosystemDeps: dependencies.filter(d => 
          this.normalizeEcosystem(d.packageManager) === this.normalizeEcosystem(affectedPackage.ecosystem)
        ).length
      });
      
      // Strategy 1: Exact match
      const exactMatches = dependencies.filter(dep => 
        this.isExactMatch(dep, affectedPackage.name, affectedPackage.ecosystem) &&
        this.isVersionAffected(dep.version, affectedPackage.affectedVersions)
      );

      if (exactMatches.length > 0) {
        logger.info(`    ✅ Found ${exactMatches.length} exact matches for ${affectedPackage.name}`);
      }

      // Strategy 2: Partial/fuzzy match for Maven packages
      const partialMatches = dependencies.filter(dep => 
        this.isPartialMatch(dep, affectedPackage.name, affectedPackage.ecosystem) &&
        this.isVersionAffected(dep.version, affectedPackage.affectedVersions)
      );

      if (partialMatches.length > 0) {
        logger.info(`    ✅ Found ${partialMatches.length} partial matches for ${affectedPackage.name}`);
      }

      // Strategy 3: Transitive dependency inference (for Spring Boot starters)
      const transitiveMatches = dependencies.filter(dep => 
        this.isTransitiveMatch(dep, affectedPackage.name, affectedPackage.ecosystem) &&
        this.isVersionAffected(dep.version, affectedPackage.affectedVersions)
      );

      if (transitiveMatches.length > 0) {
        logger.info(`    ✅ Found ${transitiveMatches.length} transitive matches for ${affectedPackage.name}`);
      }

      // Combine matches and deduplicate
      const allMatches = [...exactMatches, ...partialMatches, ...transitiveMatches];
      const uniqueMatches = allMatches.filter((dep, index, arr) => 
        arr.findIndex(d => d.name === dep.name && d.packageManager === dep.packageManager) === index
      );

      if (uniqueMatches.length === 0) {
        logger.warn(`    ❌ NO MATCHES for ${affectedPackage.name} (${affectedPackage.ecosystem})`);
        logger.warn(`    📋 Checked against ${dependencies.length} total dependencies`);
        
        // Log some examples of what we're checking against
        const sampleDeps = dependencies
          .filter(d => this.normalizeEcosystem(d.packageManager) === this.normalizeEcosystem(affectedPackage.ecosystem))
          .slice(0, 3)
          .map(d => `${d.name}:${d.version}`);
        
        if (sampleDeps.length > 0) {
          logger.warn(`    🔍 Sample ${this.normalizeEcosystem(affectedPackage.ecosystem)} dependencies: ${sampleDeps.join(', ')}`);
        } else {
          logger.warn(`    🔍 No dependencies found with ecosystem: ${this.normalizeEcosystem(affectedPackage.ecosystem)}`);
        }
      }

      // Add unique matches to the results
      for (const match of uniqueMatches) {
        if (!matches.find(existing => 
          existing.name === match.name && existing.packageManager === match.packageManager
        )) {
          matches.push(match);
          logger.info(`    🎯 MATCH FOUND: ${match.name} (${match.packageManager}) matches ${affectedPackage.name} (${affectedPackage.ecosystem})`);
        }
      }
    }

    logger.info(`    📊 Total matches found: ${matches.length}`);
    return matches;
  }

  /**
   * Check for exact dependency match
   */
  private isExactMatch(dependency: Dependency, packageName: string, ecosystem: string): boolean {
    // Normalize ecosystems for compatibility
    const depEcosystem = this.normalizeEcosystem(dependency.packageManager);
    const vulnEcosystem = this.normalizeEcosystem(ecosystem);

    if (depEcosystem !== vulnEcosystem) {
      return false;
    }

    // Exact name match (case-insensitive)
    return dependency.name.toLowerCase() === packageName.toLowerCase();
  }

  /**
   * Check for partial/fuzzy dependency match (for Maven packages)
   */
  private isPartialMatch(dependency: Dependency, packageName: string, ecosystem: string): boolean {
    // Only apply partial matching to Maven/Gradle ecosystem
    const depEcosystem = this.normalizeEcosystem(dependency.packageManager);
    const vulnEcosystem = this.normalizeEcosystem(ecosystem);

    if (depEcosystem !== vulnEcosystem || vulnEcosystem !== 'maven') {
      return false;
    }

    const depName = dependency.name.toLowerCase();
    const vulnName = packageName.toLowerCase();

    // Strategy 1: Extract artifact name from Maven coordinates
    // org.springframework.security:spring-security-web -> spring-security-web
    const vulnArtifact = vulnName.includes(':') ? vulnName.split(':')[1] : vulnName;
    const depArtifact = depName.includes(':') ? depName.split(':')[1] : depName;

    if (depArtifact === vulnArtifact) {
      logger.info(`📦 Partial match (artifact): ${depName} matches ${vulnName}`);
      return true;
    }

    // Strategy 2: Check if dependency contains the vulnerable package
    // spring-boot-starter-web contains spring-webmvc functionality
    // But be more strict to prevent false positives like feign-gson matching gson
    if (depName.includes(vulnArtifact) || vulnArtifact.includes(depArtifact)) {
      // Additional check: ensure it's not just a substring match
      // e.g., "feign-gson" should not match "gson"
      const depWords = depName.split(/[-._]/);
      const vulnWords = vulnName.split(/[-._]/);
      
      // Check if any complete word matches
      const hasWordMatch = depWords.some(word => vulnWords.includes(word)) ||
                          vulnWords.some(word => depWords.includes(word));
      
      if (hasWordMatch) {
        // Additional strictness: for single-word artifacts, require exact match
        // This prevents "feign-gson" from matching "gson"
        if (vulnWords.length === 1 && depWords.length > 1) {
          // If target is a single word (like "gson") and dependency has multiple words (like "feign-gson")
          // Only match if the dependency is a clear variant (starts with the target word)
          const targetWord = vulnWords[0];
          const depArtifactOnly = depName.includes(':') ? depName.split(':')[1] : depName;
          
          // Only allow matches where the dependency starts with the target word
          // This allows "gson-core" to match "gson" but prevents "feign-gson" from matching "gson"
          if (!depArtifactOnly.startsWith(targetWord)) {
            logger.info(`📦 Rejecting partial match: ${depName} contains ${vulnName} but is not a direct variant (should start with ${targetWord})`);
            return false;
          }
        }
        
        logger.info(`📦 Partial match (contains): ${depName} contains ${vulnName}`);
        return true;
      }
    }

    return false;
  }

  /**
   * Check for transitive dependency match (Spring Boot starter inference)
   */
  private isTransitiveMatch(dependency: Dependency, packageName: string, ecosystem: string): boolean {
    // Only apply to Maven/Gradle ecosystem
    const depEcosystem = this.normalizeEcosystem(dependency.packageManager);
    const vulnEcosystem = this.normalizeEcosystem(ecosystem);

    if (depEcosystem !== vulnEcosystem || vulnEcosystem !== 'maven') {
      return false;
    }

    const depName = dependency.name.toLowerCase();
    const vulnName = packageName.toLowerCase();

    // Map Spring Boot starters to their likely transitive dependencies
    const starterMappings: Record<string, string[]> = {
      'spring-boot-starter-web': [
        'spring-webmvc', 'spring-web', 'spring-core', 'spring-context',
        'tomcat-embed-core', 'tomcat-embed-jasper', 'jackson-databind'
      ],
      'spring-boot-starter-security': [
        'spring-security-web', 'spring-security-config', 'spring-security-core',
        'spring-security-crypto'
      ],
      'spring-boot-starter-data-jpa': [
        'spring-data-jpa', 'hibernate-core', 'spring-orm'
      ],
      'spring-boot-starter-test': [
        'junit', 'mockito-core', 'spring-test'
      ],
      'spring-boot-starter': [
        'spring-boot', 'spring-core', 'spring-context', 'logback-classic', 'logback-core'
      ]
    };

    // Check if dependency is a Spring Boot starter
    for (const [starter, transitives] of Object.entries(starterMappings)) {
      if (depName.includes(starter)) {
        // Check if vulnerability package matches any transitive
        for (const transitive of transitives) {
          const vulnArtifact = vulnName.includes(':') ? vulnName.split(':')[1] : vulnName;
          
          if (vulnArtifact.includes(transitive) || transitive.includes(vulnArtifact)) {
            logger.info(`🔗 Transitive match: ${depName} (${starter}) likely includes ${vulnName} (${transitive})`);
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Enhanced version checking with better semver support
   */
  private isVersionAffected(version: string, affectedVersions: string[]): boolean {
    // Handle wildcard versions
    if (affectedVersions.includes('*') || version === '*') {
      return true;
    }

    // Handle Gradle variables like ${springBootVersion}
    if (version.startsWith('${') && version.endsWith('}')) {
      logger.info(`🔧 Gradle variable detected: ${version} - assuming affected for safety`);
      return true; // Conservative assumption for Gradle variables
    }

    try {
      const depVersion = semver.coerce(version);
      if (!depVersion) {
        logger.warn(`⚠️ Cannot parse version: ${version} - assuming affected`);
        return true; // If we can't parse version, assume affected for safety
      }

      for (const affectedRange of affectedVersions) {
        if (this.isVersionInRange(depVersion.version, affectedRange)) {
          return true;
        }
      }

      return false;
    } catch (error) {
      logger.warn(`⚠️ Version comparison error for ${version}:`, error);
      // If semver parsing fails, do string comparison
      return affectedVersions.some(range => 
        version.includes(range) || range.includes(version) || range === '*'
      );
    }
  }

  /**
   * Check if version is in affected range
   */
  private isVersionInRange(version: string, range: string): boolean {
    if (range === '*') return true;
    
    try {
      // Handle common range formats
      if (range.startsWith('>=') || range.startsWith('<=') || range.startsWith('>') || range.startsWith('<')) {
        return semver.satisfies(version, range);
      }
      
      // Exact version match
      if (semver.eq(version, range)) {
        return true;
      }
      
      // Range like "1.0.0 - 2.0.0"
      if (range.includes(' - ')) {
        return semver.satisfies(version, range);
      }
      
      return false;
    } catch {
      // Fallback to string comparison
      return version === range || range === '*';
    }
  }

  /**
   * Normalize ecosystems for compatibility (same logic as DependencyAnalyzer)
   */
  private normalizeEcosystem(ecosystem: string): string {
    if (ecosystem === 'gradle' || ecosystem === 'maven') return 'maven';
    return ecosystem;
  }

  /**
   * Generate fix suggestions for a vulnerability
   */
  private async generateFixSuggestions(
    vulnerability: Vulnerability,
    affectedDependencies: Dependency[]
  ): Promise<FixSuggestion[]> {
    const suggestions: FixSuggestion[] = [];

    for (const dependency of affectedDependencies) {
      // Find fixed versions for this vulnerability
      const affectedPackage = vulnerability.affectedPackages.find(pkg => 
        pkg.name.toLowerCase() === dependency.name.toLowerCase()
      );

      if (affectedPackage && affectedPackage.fixedVersions.length > 0) {
        // Choose the best fixed version (lowest version that fixes the issue)
        const suggestedVersion = affectedPackage.fixedVersions[0];
        
        // Determine update type (simplified)
        const updateType = this.determineUpdateType(dependency.version, suggestedVersion);

        const suggestion: FixSuggestion = {
          id: `fix-${dependency.name}-${vulnerability.id}`,
          dependencyName: dependency.name,
          currentVersion: dependency.version,
          suggestedVersion,
          updateType,
          fixesVulnerabilities: [vulnerability.cveId || vulnerability.id],
          breakingChanges: [],
          migrationNotes: this.generateMigrationNotes(dependency, updateType),
          confidence: this.calculateConfidence(updateType, dependency.isDev),
          testingRequired: updateType === 'major' || !dependency.isDev,
        };

        suggestions.push(suggestion);
      } else {
        // No specific fixed version available, suggest latest
        const suggestion: FixSuggestion = {
          id: `fix-${dependency.name}-${vulnerability.id}`,
          dependencyName: dependency.name,
          currentVersion: dependency.version,
          suggestedVersion: 'latest',
          updateType: 'major', // Conservative assumption
          fixesVulnerabilities: [vulnerability.cveId || vulnerability.id],
          breakingChanges: [{
            type: 'api',
            description: 'Version update may include breaking changes',
            mitigation: 'Review changelog and test thoroughly',
          }],
          migrationNotes: 'No specific fixed version available. Update to latest version and verify functionality.',
          confidence: 0.6, // Lower confidence when no specific fix version
          testingRequired: true,
        };

        suggestions.push(suggestion);
      }
    }

    return suggestions;
  }

  /**
   * Determine the type of update (patch, minor, major)
   */
  private determineUpdateType(currentVersion: string, suggestedVersion: string): 'patch' | 'minor' | 'major' | 'alternative' {
    if (suggestedVersion === 'latest') {
      return 'major'; // Conservative assumption
    }

    try {
      // Try semver first
      const semver = require('semver');
      const current = semver.coerce(currentVersion);
      const suggested = semver.coerce(suggestedVersion);
      
      if (current && suggested) {
        if (semver.major(suggested) > semver.major(current)) {
          return 'major';
        } else if (semver.minor(suggested) > semver.minor(current)) {
          return 'minor';
        } else {
          return 'patch';
        }
      }
    } catch (error) {
      logger.warn('Error using semver for version comparison:', error);
    }

    // Fallback: Simplified version comparison
    const current = currentVersion.split('.').map(Number).filter(n => !isNaN(n));
    const suggested = suggestedVersion.split('.').map(Number).filter(n => !isNaN(n));

    if (current.length === 0 || suggested.length === 0) {
      return 'minor'; // Less conservative default when we can't parse versions
    }

    // Compare available version parts
    const maxLength = Math.max(current.length, suggested.length);
    for (let i = 0; i < maxLength; i++) {
      const cur = current[i] || 0;
      const sug = suggested[i] || 0;
      
      if (sug > cur) {
        if (i === 0) return 'major';
        if (i === 1) return 'minor';
        return 'patch';
      } else if (sug < cur) {
        // Downgrade scenario
        return 'alternative';
      }
    }

    return 'patch'; // Versions are equal
  }

  /**
   * Generate migration notes based on update type
   */
  private generateMigrationNotes(dependency: Dependency, updateType: 'patch' | 'minor' | 'major' | 'alternative'): string | undefined {
    switch (updateType) {
      case 'patch':
        return `This is a patch update for ${dependency.name}. Should be safe to apply with minimal risk of breaking changes.`;
      
      case 'minor':
        return `This is a minor update for ${dependency.name}. May include new features but should maintain backward compatibility. Test thoroughly.`;
      
      case 'major':
        return `This is a major update for ${dependency.name}. Likely includes breaking changes. Review the changelog and update your code accordingly. Run comprehensive tests before deploying.`;
      
      case 'alternative':
        return `Consider switching to an alternative package that doesn't have this vulnerability.`;
      
      default:
        return undefined;
    }
  }

  /**
   * Calculate confidence score for the fix suggestion
   */
  private calculateConfidence(updateType: 'patch' | 'minor' | 'major' | 'alternative', isDev: boolean): number {
    let confidence = 1.0;

    // Reduce confidence for major updates
    if (updateType === 'major') {
      confidence -= 0.3;
    } else if (updateType === 'minor') {
      confidence -= 0.1;
    } else if (updateType === 'alternative') {
      confidence -= 0.4;
    }

    // Slightly higher confidence for dev dependencies (less critical)
    if (isDev) {
      confidence += 0.05;
    }

    return Math.max(0.1, Math.min(1.0, confidence));
  }

  /**
   * Check if a package name is legitimate (not garbage data)
   */
  private isLegitimatePackage(packageName: string): boolean {
    if (!packageName || packageName.trim() === '') return false;
    
    // Filter out obvious garbage data
    const garbagePatterns = [
      /^versions@/i,                    // versions@use-latest-releases
      /^marketplace-zendesk@/i,         // repository name
      /^sha256@/i,                      // hash values
      /^[a-f0-9]{40,}$/i,              // long hex strings (hashes)
      /^[a-f0-9]{64}$/i,               // sha256 hashes
    ];

    for (const pattern of garbagePatterns) {
      if (pattern.test(packageName)) {
        return false;
      }
    }

    // Additional heuristics for legitimate packages
    const name = packageName.toLowerCase();
    
    // Too long to be a reasonable package name
    if (name.length > 150) return false;
    
    // Known legitimate package patterns
    const legitimatePatterns = [
      /^[a-z0-9-_.]+:[a-z0-9-_.]+$/i,     // Maven coordinates: group:artifact
      /^@?[a-z0-9-_./@]+$/i,              // npm packages
      /^[a-z0-9-_.]+$/i,                  // Simple package names
      /^[a-z0-9-_.]+@[0-9]/i,             // Package with version
      /^[a-z0-9-_.]+==/i,                 // Python package with version
    ];

    return legitimatePatterns.some(pattern => pattern.test(name));
  }
} 